<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>üè≥Ô∏è‚Äçüåà PRIDE AI Assistant</title>
  <style>
    /* --- ALL YOUR ORIGINAL STYLES HAVE BEEN RESTORED --- */
    @import url('https://fonts.googleapis.com/css2?family=Comic+Neue:wght@700&family=Poppins:wght@400;600&display=swap');

    body {
      background: linear-gradient(135deg, #ff9a9e, #fad0c4, #fad0c4, #a1c4fd, #c2e9fb, #d1c4e9, #f8bbd0);
      background-size: 600% 600%;
      animation: gradient 16s ease infinite;
      font-family: 'Poppins', sans-serif;
      margin: 0;
      height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    @keyframes gradient {
      0% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
      100% { background-position: 0% 50%; }
    }

    .container {
      text-align: center;
      max-width: 800px;
      padding: 40px;
      background: rgba(255, 255, 255, 0.2);
      backdrop-filter: blur(10px);
      border-radius: 20px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
      border: 2px solid rgba(255, 255, 255, 0.3);
    }

    h1 {
      font-family: 'Comic Neue', cursive;
      font-size: 5rem;
      font-weight: 900;
      background: linear-gradient(to right, #ff0000, #ff7700, #ffef00, #32cc00, #00aaff, #cc00ff);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
      margin: 0;
      letter-spacing: 4px;
    }

    p {
      color: white;
      text-shadow: 1px 1px 3px rgba(0,0,0,0.5);
      font-size: 1.2rem;
    }

    .btn {
      font-size: 1.4rem;
      padding: 14px 30px;
      margin: 20px 0;
      border: none;
      border-radius: 50px;
      cursor: pointer;
      font-weight: bold;
      transition: all 0.3s ease;
    }

    .btn-mic {
      background: #fff;
      color: #d13080;
      box-shadow: 0 4px 15px rgba(255, 100, 180, 0.4);
    }

    .btn-mic:hover {
      transform: scale(1.05);
      box-shadow: 0 6px 20px rgba(255, 100, 180, 0.6);
    }

    textarea {
      border-radius: 12px;
      border: 2px solid #fff;
      background: rgba(255, 255, 255, 0.4);
      color: #333;
      font-size: 1rem;
      padding: 10px;
    }

    .ripple {
      display: inline-block;
      margin: 15px auto;
    }

    .ripple span {
      display: inline-block;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: #fff;
      margin: 0 4px;
      animation: pulse 1.2s infinite ease-in-out;
    }

    .ripple span:nth-child(2) { animation-delay: 0.2s; }
    .ripple span:nth-child(3) { animation-delay: 0.4s; }

    @keyframes pulse {
      0%, 100% { transform: scale(0.8); opacity: 0.6; }
      50% { transform: scale(1.2); opacity: 1; }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>PRIDE</h1>
    <p><small>üéôÔ∏è Hold to speak. AI speaks back with love.</small></p>

    <button id="recordBtn" class="btn btn-mic">üé§ Hold to Speak</button>

    <div class="mb-3 text-start" style="color:white; margin-top:20px;">
      <strong>You said:</strong>
      <textarea id="userText" class="form-control w-100" rows="2" readonly placeholder="Waiting for speech..."></textarea>
    </div>

    <div class="mb-3 text-start" style="color:white;">
      <strong>AI says:</strong>
      <textarea id="aiText" class="form-control w-100" rows="2" readonly placeholder="AI will reply here..."></textarea>
    </div>

    <div id="aiRipple" style="display:none; color:white;">
      <strong>AI is speaking:</strong>
      <div class="ripple">
        <span></span>
        <span></span>
        <span></span>
      </div>
    </div>

    <audio id="audioPlayer" controls style="display:none; width:100%; margin-top:10px;"></audio>
  </div>

  <script src="/static/record.js"></script>
    <script>
        const recordBtn = document.getElementById("recordBtn");
        const userText = document.getElementById("userText");
        const aiText = document.getElementById("aiText");
        const audioPlayer = document.getElementById("audioPlayer");
        const aiRipple = document.getElementById("aiRipple");

        let recorder;
        let audioContext;
        let isRecording = false;
        let isInitializing = false;

        async function initRecorder() {
            if (isInitializing || recorder) return true;

            isInitializing = true;
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                const source = audioContext.createMediaStreamSource(stream);
                recorder = new Recorder(source, { 
                    numberOfChannels: 1,
                    sampleRate: 16000,
                    bufferLen: 4096
                });
                console.log("üé§ Recorder initialized successfully");
                isInitializing = false;
                return true;
            } catch (err) {
                console.error("üö´ Microphone initialization failed. Error details:", err);
                let userMessage = "Could not access the microphone. ";
                if (err.name === 'NotAllowedError' || err.name === 'PermissionDeniedError') {
                    userMessage += "Permission was denied. Please check your OS security settings for Microphone.";
                } else if (err.name === 'NotFoundError' || err.name === 'DevicesNotFoundError') {
                    userMessage += "No microphone was found. Please ensure it's connected.";
                } else {
                    userMessage += `An unexpected error occurred: ${err.name}. Check the console.`;
                }
                alert(userMessage);
                isInitializing = false;
                return false;
            }
        }

    // --- MOUSE DOWN EVENT ---
    recordBtn.addEventListener("mousedown", async () => {
      // Initialize recorder if it hasn't been already
      const ready = await initRecorder();
      if (!ready || isRecording) return; // Exit if not ready or already recording

      recorder.record();
      isRecording = true;
      recordBtn.textContent = "üõë Recording...";
      recordBtn.style.background = "#ff3366";
      recordBtn.style.transform = "scale(1.05)";
    });

    // --- MOUSE UP EVENT ---
    recordBtn.addEventListener("mouseup", () => {
      // Ensure we are in a recording state before stopping
      if (!recorder || !isRecording) return;

      recorder.stop();
      isRecording = false; // Update state
      recordBtn.textContent = "Processing...";

      // Export the audio to a WAV blob
      recorder.exportWAV((blob) => {
        const formData = new FormData();
        formData.append("audio", blob, "input.wav");

        // Chain the API calls
        fetch("/transcribe", { method: "POST", body: formData })
          .then(response => {
            if (!response.ok) throw new Error(`Transcription failed: ${response.statusText}`);
            return response.json();
          })
          .then(data => {
            userText.value = data.text;
            return fetch("/generate", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ text: data.text })
            });
          })
          .then(response => {
            if (!response.ok) throw new Error(`AI generation failed: ${response.statusText}`);
            return response.json();
          })
          .then(data => {
            aiText.value = data.reply;
            aiRipple.style.display = "block";
            audioPlayer.style.display = 'block'; // Show player
            return fetch("/tts", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ text: data.reply })
            });
          })
          .then(response => {
            if (!response.ok) throw new Error(`Text-to-speech failed: ${response.statusText}`);
            return response.json();
          })
          .then(data => {
            // Use a cache-busting query to ensure the new audio file is loaded
            audioPlayer.src = data.audio_url + "?t=" + new Date().getTime();
            audioPlayer.play();
          })
          .catch(err => {
            console.error("üí• An error occurred in the processing chain:", err);
            alert("An error occurred. Please check the console for details.");
          })
          .finally(() => {
            // Reset button regardless of success or failure
            recordBtn.textContent = "üé§ Hold to Speak";
            recordBtn.style.background = "#fff";
            recordBtn.style.transform = "scale(1)";
          });

        recorder.clear(); // Clear the buffer for the next recording
      });
    });

    // Hide the ripple effect when the AI stops speaking
    audioPlayer.addEventListener("ended", () => {
      aiRipple.style.display = "none";
    });

  </script>
</body>
</html>