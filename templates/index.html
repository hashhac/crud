<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>ğŸ³ï¸â€ğŸŒˆ PRIDE AI Assistant</title>
  <link rel="stylesheet" href="/static/style.css">
</head>
<body>
  <div class="container">
    <h1>PRIDE</h1>
    <p><small>ğŸ™ï¸ Hold to speak. AI speaks back with love.</small></p>

    <button id="recordBtn" class="btn btn-mic">ğŸ¤ Hold to Speak</button>
    <button id="clearHistoryBtn" class="btn" style="background: rgba(255,255,255,0.2); color: white; font-size: 0.9rem; padding: 8px 16px; margin-left: 10px;">ğŸ—‘ï¸ Clear History</button>

    <div class="mb-3 text-start" style="color:white; margin-top:20px;">
      <strong>You said:</strong>
      <textarea id="userText" class="form-control w-100" rows="2" readonly placeholder="Waiting for speech..."></textarea>
    </div>

    <div class="mb-3 text-start" style="color:white;">
      <strong>AI says:</strong>
      <textarea id="aiText" class="form-control w-100" rows="2" readonly placeholder="AI will reply here..."></textarea>
    </div>

    <div id="contextInfo" style="color: rgba(255,255,255,0.7); font-size: 0.8rem; margin-bottom: 10px; display: none;">
      ğŸ’­ <span id="contextText">Conversation context active</span>
    </div>

    <div id="aiRipple" style="display:none; color:white;">
      <strong>AI is speaking:</strong>
      <div class="ripple">
        <span></span>
        <span></span>
        <span></span>
      </div>
    </div>

    <audio id="audioPlayer" controls style="display:none; width:100%; margin-top:10px;"></audio>
  </div>

  <script src="/static/record.js"></script>
    <script>
        const recordBtn = document.getElementById("recordBtn");
        const userText = document.getElementById("userText");
        const aiText = document.getElementById("aiText");
        const audioPlayer = document.getElementById("audioPlayer");
        const aiRipple = document.getElementById("aiRipple");
        const contextInfo = document.getElementById("contextInfo");
        const contextText = document.getElementById("contextText");

        let recorder;
        let audioContext;
        let isRecording = false;
        let isInitializing = false;

        async function initRecorder() {
            if (isInitializing || recorder) return true;

            isInitializing = true;
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                const source = audioContext.createMediaStreamSource(stream);
                recorder = new Recorder(source, { 
                    numberOfChannels: 1,
                    sampleRate: 16000,
                    bufferLen: 4096
                });
                console.log("ğŸ¤ Recorder initialized successfully");
                isInitializing = false;
                return true;
            } catch (err) {
                console.error("ğŸš« Microphone initialization failed. Error details:", err);
                let userMessage = "Could not access the microphone. ";
                if (err.name === 'NotAllowedError' || err.name === 'PermissionDeniedError') {
                    userMessage += "Permission was denied. Please check your OS security settings for Microphone.";
                } else if (err.name === 'NotFoundError' || err.name === 'DevicesNotFoundError') {
                    userMessage += "No microphone was found. Please ensure it's connected.";
                } else {
                    userMessage += `An unexpected error occurred: ${err.name}. Check the console.`;
                }
                alert(userMessage);
                isInitializing = false;
                return false;
            }
        }

    // --- MOUSE DOWN EVENT ---
    recordBtn.addEventListener("mousedown", async () => {
      // Initialize recorder if it hasn't been already
      const ready = await initRecorder();
      if (!ready || isRecording) return; // Exit if not ready or already recording

      recorder.record();
      isRecording = true;
      recordBtn.textContent = "ğŸ›‘ Recording...";
      recordBtn.style.background = "#ff3366";
      recordBtn.style.transform = "scale(1.05)";
    });

    // --- MOUSE UP EVENT ---
    recordBtn.addEventListener("mouseup", () => {
      // Ensure we are in a recording state before stopping
      if (!recorder || !isRecording) return;

      recorder.stop();
      isRecording = false; // Update state
      recordBtn.textContent = "Processing...";

      // Export the audio to a WAV blob
      recorder.exportWAV((blob) => {
        const formData = new FormData();
        formData.append("audio", blob, "input.wav");

        // Chain the API calls
        fetch("/transcribe", { method: "POST", body: formData })
          .then(response => {
            if (!response.ok) throw new Error(`Transcription failed: ${response.statusText}`);
            return response.json();
          })
          .then(data => {
            userText.value = data.text;
            return fetch("/generate", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ text: data.text })
            });
          })
          .then(response => {
            if (!response.ok) throw new Error(`AI generation failed: ${response.statusText}`);
            return response.json();
          })
          .then(data => {
            aiText.value = data.reply;
            
            // Show context information if available
            if (data.context_info && data.context_info.total_exchanges > 0) {
              contextText.textContent = `${data.context_info.total_exchanges} exchanges, ~${data.context_info.estimated_tokens} tokens`;
              contextInfo.style.display = "block";
            } else {
              contextInfo.style.display = "none";
            }
            
            aiRipple.style.display = "block";
            audioPlayer.style.display = 'block'; // Show player
            return fetch("/tts", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ text: data.reply })
            });
          })
          .then(response => {
            if (!response.ok) throw new Error(`Text-to-speech failed: ${response.statusText}`);
            return response.json();
          })
          .then(data => {
            // Use a cache-busting query to ensure the new audio file is loaded
            audioPlayer.src = data.audio_url + "?t=" + new Date().getTime();
            audioPlayer.play();
          })
          .catch(err => {
            console.error("ğŸ’¥ An error occurred in the processing chain:", err);
            alert("An error occurred. Please check the console for details.");
          })
          .finally(() => {
            // Reset button regardless of success or failure
            recordBtn.textContent = "ğŸ¤ Hold to Speak";
            recordBtn.style.background = "#fff";
            recordBtn.style.transform = "scale(1)";
          });

        recorder.clear(); // Clear the buffer for the next recording
      });
    });

    // Hide the ripple effect when the AI stops speaking
    audioPlayer.addEventListener("ended", () => {
      aiRipple.style.display = "none";
    });

    // Clear conversation history functionality
    const clearHistoryBtn = document.getElementById("clearHistoryBtn");
    clearHistoryBtn.addEventListener("click", async () => {
      try {
        const response = await fetch("/conversation/clear", { method: "POST" });
        const data = await response.json();
        
        if (response.ok) {
          // Clear the displayed conversation
          userText.value = "";
          aiText.value = "";
          contextInfo.style.display = "none";
          
          // Visual feedback
          clearHistoryBtn.textContent = "âœ… Cleared";
          setTimeout(() => {
            clearHistoryBtn.textContent = "ğŸ—‘ï¸ Clear History";
          }, 2000);
          
          console.log("Conversation history cleared");
        } else {
          console.error("Failed to clear history:", data);
        }
      } catch (err) {
        console.error("Error clearing history:", err);
      }
    });

  </script>
</body>
</html>